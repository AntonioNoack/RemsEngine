package me.anno.io

import me.anno.audio.AudioReadable
import me.anno.cache.AsyncCacheData
import me.anno.cache.CacheSection
import me.anno.cache.FileCacheSection.getFileEntry
import me.anno.cache.FileCacheSection.getFileEntryAsync
import me.anno.cache.ICacheData
import me.anno.image.ImageReadable
import me.anno.io.files.FileKey
import me.anno.io.files.FileReference
import me.anno.io.files.SignatureCache
import me.anno.utils.Sleep
import me.anno.utils.async.Callback
import me.anno.utils.structures.tuples.IntPair
import me.anno.utils.types.Strings.formatTime
import me.anno.utils.types.Strings.shorten
import org.apache.logging.log4j.LogManager
import java.io.InputStream

/**
 * Metadata for audio/video/images.
 * Typically generated by FFMPEG, but some special cases are handled by our own readers.
 * */
class MediaMetadata(val file: FileReference, val signature: String?, ri: Int) : ICacheData {

    var duration = 0.0

    var hasAudio = false // has sound/music/audio
    var hasVideo = false // has image or video data

    var audioStartTime = 0.0
    var audioSampleRate = 0
    var audioDuration = 0.0
    var audioSampleCount = 0L // 24h * 3600s/h * 48k = 4B -> Long
    var audioChannels = 0

    var videoStartTime = 0.0
    var videoFPS = 0.0
    var videoDuration = 0.0
    var videoWidth = 0
    var videoHeight = 0
    var videoFrameCount = 0

    var isReady = true

    override fun toString(): String {
        return "FFMPEGMetadata(file: ${file.absolutePath.shorten(200)}, audio: ${
            if (hasAudio) "[$audioSampleRate Hz, $audioChannels ch]" else "false"
        }, video: ${
            if (hasVideo) "[$videoWidth x $videoHeight, $videoFrameCount]" else "false"
        }, duration: ${duration.formatTime(3)}), channels: $audioChannels"
    }

    init {
        continueReading(ri)
    }

    fun continueReading(nextReaderIndex: Int) {
        // type handlers
        var currReaderIndex = 0
        for (thi in typeHandlers.indices) {
            if (currReaderIndex++ < nextReaderIndex) continue
            val th = typeHandlers[thi]
            if (th.reader.handle(file, this, currReaderIndex)) {
                return
            }
        }
        // signature handlers
        val signature1 = signature ?: SignatureCache[file, false].waitFor()?.name
        for (shi in signatureHandlers.indices) {
            if (currReaderIndex++ < nextReaderIndex) continue
            val sh = signatureHandlers[shi]
            if (sh.reader.handle(file, signature1, this, currReaderIndex)) {
                return
            }
        }
        LOGGER.debug(
            "{}'s signature wasn't registered in FFMPEGMetadata.kt: '{}'",
            file.absolutePath, signature1
        )
    }

    fun setImageSize(wh: IntPair) {
        setImageSize(wh.first, wh.second)
    }

    fun setImageSize(w: Int, h: Int) {
        hasVideo = true
        videoWidth = w
        videoHeight = h
        videoFrameCount = 1
        duration = Double.POSITIVE_INFINITY // actual value isn't really well-defined
    }

    fun setImageByStream(callback: (InputStream) -> Any, nextReaderIndex: Int): Boolean {
        isReady = false
        file.inputStream { it, exc ->
            if (it != null) {
                val size = callback(it)
                if (size is IntPair) {
                    setImageSize(size)
                } else if (size is Exception) {
                    if (nextReaderIndex > 0) continueReading(nextReaderIndex)
                    else size.printStackTrace()
                } // else unknown case...
            } else exc?.printStackTrace()
            isReady = true
        }
        return true
    }

    companion object {

        data class Handler<V>(val priority: Int, val signature: String, val reader: V)

        fun interface TypeHandler {
            fun handle(file: FileReference, dst: MediaMetadata, nextReaderIndex: Int): Boolean
        }

        fun interface SignatureHandler {
            fun handle(file: FileReference, signature: String?, dst: MediaMetadata, nextReaderIndex: Int): Boolean
        }

        var timeoutMillis = 300_000L
        private val typeHandlers = ArrayList<Handler<TypeHandler>>()
        private val signatureHandlers = ArrayList<Handler<SignatureHandler>>()

        private fun <V> registerHandler(list: ArrayList<Handler<V>>, priority: Int, key: String, value: V) {
            synchronized(signatureHandlers) {
                var idx = list.binarySearch { it.priority.compareTo(priority) }
                if (idx < 0) idx = -idx - 1
                list.add(idx, Handler(priority, key, value))
            }
        }

        fun registerHandler(order: Int, key: String, handler: TypeHandler) {
            registerHandler(typeHandlers, order, key, handler)
        }

        fun registerSignatureHandler(order: Int, key: String, handler: SignatureHandler) {
            registerHandler(signatureHandlers, order, key, handler)
        }

        fun unregister(keys: String) {
            val keys1 = keys.split(',')
            synchronized(signatureHandlers) {
                typeHandlers.removeAll { it.signature in keys1 }
                signatureHandlers.removeAll { it.signature in keys1 }
            }
        }

        @JvmStatic
        private val LOGGER = LogManager.getLogger(MediaMetadata::class)

        @JvmStatic
        private val metadataCache = CacheSection<FileKey, MediaMetadata>("Metadata")

        @JvmStatic
        private val createMetadata: (FileKey, AsyncCacheData<MediaMetadata>) -> Unit = { key, result ->
            val meta = MediaMetadata(key.file, null, 0)
            Sleep.waitUntil(true, { meta.isReady }) {
                result.value = meta
            }
        }

        @JvmStatic
        private fun createMetadata(file: FileReference, signature: String?): MediaMetadata {
            return MediaMetadata(file, signature ?: "", 0)
        }

        @JvmStatic
        fun getMeta(file: FileReference, async: Boolean): MediaMetadata? {
            return metadataCache.getFileEntry(
                file, false, timeoutMillis,
                async, createMetadata
            ).waitFor(async)
        }

        @JvmStatic
        fun getMetaAsync(file: FileReference, callback: Callback<MediaMetadata>) {
            metadataCache.getFileEntryAsync(
                file, false, timeoutMillis,
                true, createMetadata,
                callback
            )
        }

        @JvmStatic
        fun getMeta(file: FileReference, signature: String?, async: Boolean): MediaMetadata? {
            return metadataCache.getFileEntry(file, false, timeoutMillis, async) { key, result ->
                val meta = createMetadata(key.file, signature)
                Sleep.waitUntil(true, { meta.isReady }) {
                    result.value = meta
                }
            }.waitFor(async)
        }

        init {
            registerHandler(100, "audio-readable") { file, dst, _ ->
                if (file is AudioReadable) {
                    dst.hasAudio = true
                    dst.audioChannels = file.channels
                    dst.audioSampleRate = file.sampleRate
                    dst.audioSampleCount = file.sampleCount
                    dst.audioDuration = file.duration
                    dst.duration = dst.audioDuration
                    true
                } else false
            }
            registerHandler(150, "image-readable") { file, dst, _ ->
                if (file is ImageReadable) {
                    dst.setImageSize(file.readSize())
                    true
                } else false
            }
        }
    }
}